//
// Observation.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



public struct BrAPIObservation: Codable {

    /** Additional arbitrary info */
    public var additionalInfo: [String:String]?
    /** The name or identifier of the entity which collected the observation */
    public var collector: String?
    /** An array of external reference ids. These are references to this piece of data in an external system. Could be a simple string or a URI. */
    public var externalReferences: [BrAPIExternalReferencesInner]?
    /** The ID which uniquely identifies a germplasm */
    public var germplasmDbId: String?
    /** Name of the germplasm. It can be the preferred name and does not have to be unique. */
    public var germplasmName: String?
    /** The ID which uniquely identifies an observation */
    public var observationDbId: String?
    /** The date and time when this observation was made */
    public var observationTimeStamp: Date?
    /** The ID which uniquely identifies an observation unit */
    public var observationUnitDbId: String?
    /** A human readable name for an observation unit */
    public var observationUnitName: String?
    /** The ID which uniquely identifies an observation variable */
    public var observationVariableDbId: String?
    /** A human readable name for an observation variable */
    public var observationVariableName: String?
    public var season: BrAPISeason?
    /** The ID which uniquely identifies a study within the given database server */
    public var studyDbId: String?
    /** The name or id of the user who uploaded the observation to the database system */
    public var uploadedBy: String?
    /** The value of the data collected as an observation */
    public var value: String?

    public init(additionalInfo: [String:String]? = nil, collector: String? = nil, externalReferences: [BrAPIExternalReferencesInner]? = nil, germplasmDbId: String? = nil, germplasmName: String? = nil, observationDbId: String? = nil, observationTimeStamp: Date? = nil, observationUnitDbId: String? = nil, observationUnitName: String? = nil, observationVariableDbId: String? = nil, observationVariableName: String? = nil, season: BrAPISeason? = nil, studyDbId: String? = nil, uploadedBy: String? = nil, value: String? = nil) {
        self.additionalInfo = additionalInfo
        self.collector = collector
        self.externalReferences = externalReferences
        self.germplasmDbId = germplasmDbId
        self.germplasmName = germplasmName
        self.observationDbId = observationDbId
        self.observationTimeStamp = observationTimeStamp
        self.observationUnitDbId = observationUnitDbId
        self.observationUnitName = observationUnitName
        self.observationVariableDbId = observationVariableDbId
        self.observationVariableName = observationVariableName
        self.season = season
        self.studyDbId = studyDbId
        self.uploadedBy = uploadedBy
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        do {
            additionalInfo = try container.decode([String:String].self, forKey:.additionalInfo)
        } catch DecodingError.valueNotFound {
            additionalInfo = nil
        } catch DecodingError.keyNotFound {
            additionalInfo = nil
        }
        do {
            collector = try container.decode(String.self, forKey:.collector)
        } catch DecodingError.valueNotFound {
            collector = nil
        }
        do {
            externalReferences = try container.decode([BrAPIExternalReferencesInner].self, forKey:.externalReferences)
        } catch DecodingError.valueNotFound {
            externalReferences = nil
        } catch DecodingError.keyNotFound {
            externalReferences = nil
        }
        
        do {
            germplasmDbId = try container.decode(String.self, forKey:.germplasmDbId)
        } catch DecodingError.typeMismatch {
            germplasmDbId = try String(container.decode(Int.self, forKey: .germplasmDbId))
        }  catch DecodingError.valueNotFound {
            germplasmDbId = nil
        }
        do {
            germplasmName = try container.decode(String.self, forKey:.germplasmName)
        } catch DecodingError.valueNotFound {
            germplasmName = nil
        }
        do {
            observationDbId = try container.decode(String.self, forKey:.observationDbId)
        } catch DecodingError.typeMismatch {
            observationDbId = try String(container.decode(Int.self, forKey: .observationDbId))
        }  catch DecodingError.valueNotFound {
            observationDbId = nil
        }
        do {
            observationTimeStamp = try container.decode(Date.self, forKey:.observationTimeStamp)
        } catch DecodingError.valueNotFound {
            observationTimeStamp = nil
        }
        do {
            observationUnitDbId = try container.decode(String.self, forKey:.observationUnitDbId)
        } catch DecodingError.typeMismatch {
            observationUnitDbId = try String(container.decode(Int.self, forKey: .observationUnitDbId))
        }  catch DecodingError.valueNotFound {
            observationUnitDbId = nil
        }
        do {
            observationUnitName = try container.decode(String.self, forKey:.observationUnitName)
        } catch DecodingError.valueNotFound {
            observationUnitName = nil
        }
        do {
            observationVariableDbId = try container.decode(String.self, forKey:.observationVariableDbId)
        } catch DecodingError.typeMismatch {
            observationVariableDbId = try String(container.decode(Int.self, forKey: .observationVariableDbId))
        }  catch DecodingError.valueNotFound {
            observationVariableDbId = nil
        }
        do {
            observationVariableName = try container.decode(String.self, forKey:.observationVariableName)
        } catch DecodingError.valueNotFound {
            observationVariableName = nil
        }
        do {
            season = try container.decode(BrAPISeason.self, forKey:.season)
        } catch DecodingError.valueNotFound {
            season = nil
        } catch DecodingError.keyNotFound {
            season = nil
        }
        do {
            studyDbId = try container.decode(String.self, forKey:.studyDbId)
        } catch DecodingError.typeMismatch {
            studyDbId = try String(container.decode(Int.self, forKey: .studyDbId))
        }  catch DecodingError.valueNotFound {
            studyDbId = nil
        }
        do {
            uploadedBy = try container.decode(String.self, forKey:.uploadedBy)
        } catch DecodingError.valueNotFound {
            uploadedBy = nil
        }
        do {
            value = try container.decode(String.self, forKey:.value)
        } catch DecodingError.valueNotFound {
            value = nil
        }
    }
    
    private enum CodingKeys: String, CodingKey {
        case additionalInfo
        case collector
        case externalReferences
        case germplasmDbId
        case germplasmName
        case observationDbId
        case observationTimeStamp
        case observationUnitDbId
        case observationUnitName
        case observationVariableDbId
        case observationVariableName
        case season
        case studyDbId
        case uploadedBy
        case value
    }
}
